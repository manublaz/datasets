-- SQL queries for the dataset
-- dataset-datosbne-50k_2024-07-19.sql
-- ====================================================================


-- Total records and date ranges
-- ====================================================================
SELECT COUNT(*) AS total_records, MIN(datereg) AS start_date, MAX(datereg) AS end_date, TIMEDIFF(MAX(datereg), MIN(datereg)) AS total_duration FROM datosbne;

-- Detection of gaps in the datosBNE catalogue numbering
-- ====================================================================
WITH extracted_numbers AS ( SELECT id, url, CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(url, 'bimo', -1), '.', 1) AS UNSIGNED) AS record_number FROM datosbne ), consecutive_differences AS ( SELECT id, url, record_number, record_number - LAG(record_number) OVER (ORDER BY record_number) AS difference FROM extracted_numbers ) SELECT id, url, record_number, difference, CASE WHEN difference = 1 THEN 'Consecutive' WHEN difference IS NULL THEN 'First record' ELSE 'Gap detected' END AS sequence_type, COUNT(*) OVER (PARTITION BY CASE WHEN difference > 1 THEN 1 ELSE 0 END) AS total_gaps, AVG(CASE WHEN difference > 1 THEN difference ELSE NULL END) OVER () AS average_gap, MAX(difference) OVER () AS maximum_gap FROM consecutive_differences WHERE difference > 1 OR difference IS NULL ORDER BY record_number;

-- Waiting time between insertions, exceeding 10 seconds
-- ====================================================================
WITH extracted_numbers AS ( SELECT id, url, CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(url, 'bimo', -1), '.', 1) AS UNSIGNED) AS record_number FROM datosbne ), consecutive_differences AS ( SELECT id, url, record_number, record_number - LAG(record_number) OVER (ORDER BY record_number) AS difference FROM extracted_numbers ) SELECT COUNT(*) AS total_records, COUNT(CASE WHEN difference > 1 THEN 1 END) AS total_gaps, AVG(CASE WHEN difference > 1 THEN difference END) AS average_gap, MAX(difference) AS maximum_gap, MIN(CASE WHEN difference > 1 THEN difference END) AS minimum_gap, STDDEV(CASE WHEN difference > 1 THEN difference END) AS standard_deviation_gaps FROM consecutive_differences;

-- Summary of gap detection
-- ====================================================================
WITH ordered_records AS ( SELECT id, datereg, LAG(datereg) OVER (ORDER BY datereg) AS previous_datereg FROM datosbne ), interruptions AS ( SELECT id, datereg, previous_datereg, TIMESTAMPDIFF(SECOND, previous_datereg, datereg) AS difference_seconds FROM ordered_records WHERE TIMESTAMPDIFF(SECOND, previous_datereg, datereg) > 10 ) SELECT id AS record_id_after_interruption, datereg AS record_date_after_interruption, previous_datereg AS record_date_before_interruption, difference_seconds, CONCAT( FLOOR(difference_seconds / 3600), ' hours, ', FLOOR((difference_seconds % 3600) / 60), ' minutes, ', difference_seconds % 60, ' seconds' ) AS interruption_duration FROM interruptions ORDER BY difference_seconds DESC;

-- Maximum and minimum records inserted per minute
-- ====================================================================
SELECT MAX(records) AS max_records_per_minute, MIN(records) AS min_records_per_minute, AVG(records) AS average_records_per_minute FROM ( SELECT COUNT(*) AS records FROM datosbne GROUP BY DATE(datereg), HOUR(datereg), MINUTE(datereg) ) AS records_per_minute;

-- Maximum and minimum records inserted per hour
-- ====================================================================
SELECT MAX(records) AS max_records_per_hour, MIN(records) AS min_records_per_hour, AVG(records) AS average_records_per_hour FROM ( SELECT COUNT(*) AS records FROM datosbne GROUP BY DATE(datereg), HOUR(datereg) ) AS records_per_hour;

-- Data completion
-- ====================================================================
SELECT COUNT() AS total_records, SUM(CASE WHEN author != 'No especificado' THEN 1 ELSE 0 END) AS complete_author, SUM(CASE WHEN author != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS author_percentage, MAX(LENGTH(author)) AS max_length_author, MIN(CASE WHEN author != 'No especificado' THEN LENGTH(author) ELSE NULL END) AS min_length_author, SUM(CASE WHEN title != 'No especificado' THEN 1 ELSE 0 END) AS complete_title, SUM(CASE WHEN title != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS title_percentage, MAX(LENGTH(title)) AS max_length_title, MIN(CASE WHEN title != 'No especificado' THEN LENGTH(title) ELSE NULL END) AS min_length_title, SUM(CASE WHEN placeOfPublication != 'No especificado' THEN 1 ELSE 0 END) AS complete_placeOfPublication, SUM(CASE WHEN placeOfPublication != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS placeOfPublication_percentage, MAX(LENGTH(placeOfPublication)) AS max_length_placeOfPublication, MIN(CASE WHEN placeOfPublication != 'No especificado' THEN LENGTH(placeOfPublication) ELSE NULL END) AS min_length_placeOfPublication, SUM(CASE WHEN publisher != 'No especificado' THEN 1 ELSE 0 END) AS complete_publisher, SUM(CASE WHEN publisher != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS publisher_percentage, MAX(LENGTH(publisher)) AS max_length_publisher, MIN(CASE WHEN publisher != 'No especificado' THEN LENGTH(publisher) ELSE NULL END) AS min_length_publisher, SUM(CASE WHEN publicationDate != 'No especificado' THEN 1 ELSE 0 END) AS complete_publicationDate, SUM(CASE WHEN publicationDate != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS publicationDate_percentage, MAX(LENGTH(publicationDate)) AS max_length_publicationDate, MIN(CASE WHEN publicationDate != 'No especificado' THEN LENGTH(publicationDate) ELSE NULL END) AS min_length_publicationDate, SUM(CASE WHEN physicalDescription != 'No especificado' THEN 1 ELSE 0 END) AS complete_physicalDescription, SUM(CASE WHEN physicalDescription != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS physicalDescription_percentage, MAX(LENGTH(physicalDescription)) AS max_length_physicalDescription, MIN(CASE WHEN physicalDescription != 'No especificado' THEN LENGTH(physicalDescription) ELSE NULL END) AS min_length_physicalDescription, SUM(CASE WHEN otherPhysicalCharacteristics != 'No especificado' THEN 1 ELSE 0 END) AS complete_otherPhysicalCharacteristics, SUM(CASE WHEN otherPhysicalCharacteristics != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS otherPhysicalCharacteristics_percentage, MAX(LENGTH(otherPhysicalCharacteristics)) AS max_length_otherPhysicalCharacteristics, MIN(CASE WHEN otherPhysicalCharacteristics != 'No especificado' THEN LENGTH(otherPhysicalCharacteristics) ELSE NULL END) AS min_length_otherPhysicalCharacteristics, SUM(CASE WHEN dimensions != 'No especificado' THEN 1 ELSE 0 END) AS complete_dimensions, SUM(CASE WHEN dimensions != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS dimensions_percentage, MAX(LENGTH(dimensions)) AS max_length_dimensions, MIN(CASE WHEN dimensions != 'No especificado' THEN LENGTH(dimensions) ELSE NULL END) AS min_length_dimensions, SUM(CASE WHEN materialType != 'No especificado' THEN 1 ELSE 0 END) AS complete_materialType, SUM(CASE WHEN materialType != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS materialType_percentage, MAX(LENGTH(materialType)) AS max_length_materialType, MIN(CASE WHEN materialType != 'No especificado' THEN LENGTH(materialType) ELSE NULL END) AS min_length_materialType, SUM(CASE WHEN signature != 'No especificado' THEN 1 ELSE 0 END) AS complete_signature, SUM(CASE WHEN signature != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS signature_percentage, MAX(LENGTH(signature)) AS max_length_signature, MIN(CASE WHEN signature != 'No especificado' THEN LENGTH(signature) ELSE NULL END) AS min_length_signature, SUM(CASE WHEN location != 'No especificado' THEN 1 ELSE 0 END) AS complete_location, SUM(CASE WHEN location != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS location_percentage, MAX(LENGTH(location)) AS max_length_location, MIN(CASE WHEN location != 'No especificado' THEN LENGTH(location) ELSE NULL END) AS min_length_location, SUM(CASE WHEN headquarters != 'No especificado' THEN 1 ELSE 0 END) AS complete_headquarters, SUM(CASE WHEN headquarters != 'No especificado' THEN 1 ELSE 0 END) / COUNT() * 100 AS headquarters_percentage, MAX(LENGTH(headquarters)) AS max_length_headquarters, MIN(CASE WHEN headquarters != 'No especificado' THEN LENGTH(headquarters) ELSE NULL END) AS min_length_headquarters, ( SUM(CASE WHEN author != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN title != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN placeOfPublication != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN publisher != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN publicationDate != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN physicalDescription != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN otherPhysicalCharacteristics != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN dimensions != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN materialType != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN signature != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN location != 'No especificado' THEN 1 ELSE 0 END) + SUM(CASE WHEN headquarters != 'No especificado' THEN 1 ELSE 0 END) ) / (COUNT() * 12) * 100 AS average_percentage_completion, AVG( (CASE WHEN author != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN title != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN placeOfPublication != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN publisher != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN publicationDate != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN physicalDescription != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN otherPhysicalCharacteristics != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN dimensions != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN materialType != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN signature != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN location != 'No especificado' THEN 1 ELSE 0 END + CASE WHEN headquarters != 'No especificado' THEN 1 ELSE 0 END) / 12.0 ) * 100 AS average_percentage_completion_per_record FROM datosbne;